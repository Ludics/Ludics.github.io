# 使用 C++ 实现常用树算法

昨晚参加某互联网公司的线上笔试，编程题失手了。趁此机会复习一下树的常用算法。

### 1. 建一棵树

树，简单来说，是一个无环图。作为一个图，自然有点和边。对一棵树来说，除了根节点，其他任意一点都有唯一一条连接其父节点的边。假设 $N$ 为节点总数，$E$ 为边总数，有：
$$
N = E + 1
$$
建立一棵树的时候，和建图是一样的。因为不知道具体哪个节点是父节点，故而对于 $(u, v)$ 这条无向边，可以认为是 $u\rightarrow v$ 和 $v \rightarrow u$ 这两条有向边的集合。常用的存边方法是前向星法，以链表的形式记录一个节点所有的边。举例：

```c++
// declare
const int N = 1E5 + 5;
int first[N], vv[N * 2], nxt[N * 2], idx = 0;

// initialize
memset(first, -1, sizeof(first));  // -1 mean null

// add edge
int u = 2, v = 3;
nxt[idx] = first[u], vv[idx] = v, first[u] = idx ++;
nxt[idx] = first[v], vv[idx] = u, first[v] = idx ++;

// loop edges of node u
for (int e = first[u]; ~e; e = nxt[e]) {
  // ...
  int v = vv[e];
}
```

`first` 数组用来记录某个节点对应的链表头的位置，`nxt` 记录链表下一位的位置，`vv` 数组记录边的另一个节点，`idx` 记录链表计数。

遍历的 `for` 循环，直到 `e` 为 $-1$ 终止。可以定义一个宏，简化遍历的写法：

```c++
#define travel(e, first) for (int e = first, v = vv[first]; ~e; e = nxt[e], v = vv[e])

travel(e, first[u]) {
  printf("%d\n", v);
  // ...
}
```

### 2. 遍历一棵树

通常，使用深度优先搜索（DFS）遍历一棵树，同时记录一些重要的信息。例如：

```c++
// info of tree
int fa[N];  // father nodes
int dep[N];  // depth of nodes

// traversal
void dfs(int rt, int f, int d) {
  fa[rt] = f, dep[rt] = d;
  
  travel(e, first[rt]) if (v != f) {
    dfs(v, rt, d + 1);
  }
}
```

这里使用一个 `fa` 数组记录记录当前节点的父节点，`dep` 数组记录当前节点的深度。dfs 函数的三个参数，`rt` 表示当前节点，`f` 表示当前节点的父节点，`d` 表示当前的深度。遍历当前节点所有的边，并继续往下递归搜索即可。某些情况下还需要加入其它信息的记录，比如当前子树节点数目、最大子树节点等。

直接使用递归遍历，在数据量很大的时候会出现栈溢出的情况（真·Stack Overflow）。所以特殊情况下需要手动模拟递归的过程：使用数据结构中的栈，模拟程序执行的栈。

```c++
void dfs_safe(int rt, int f, int d) {
  struct Node { int rt, f, d; };
  stack<Node> stk;
  stk.push({rt, f, d});

  while(!stk.empty()) {
    auto now = stk.top(); stk.pop();
    int rt = now.rt, f = now.f, d = now.d;
    fa[rt] = f, dep[rt] = d;

    travel(e, first[rt]) if (v != f) {
      stk.push({v, rt, d + 1});
    }
  }
}
```

### 3. 求两个节点的最低公共祖先

最低公共祖先（Lowest Common Ancestor，LCA），即两个节点深度最大的公共祖先节点。例如下图：

```VUE
<template>
  <binary-tree :info="info">
  </binary-tree>
</template>

<script>
  export default {
    data() {
      return {
        info: [[[4], 2, [5]], 1, [[6], 3, [7]]]
      }
    }
  }
</script>
```

④ 和 ⑤ 的 LCA 就是 ②，④ 和 ⑥ 的 LCA 则为 ①。

（未完待续。。。）
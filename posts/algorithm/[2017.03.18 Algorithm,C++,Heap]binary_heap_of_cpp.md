# 使用 C++ 实现 Binary Heap

作为一个曾经的 ACM 选手，不会写堆是一种“难以启齿的柔弱”……毕竟 C++ 的优先队列（[priority_queue](http://en.cppreference.com/w/cpp/container/priority_queue)）封装的很好呀。为了实习面试，学习一下堆的相关算法。

如下图所示，这是一个最大堆（[Max Heap](https://en.wikipedia.org/wiki/Heap_(data_structure))）。

```VUE
<template>
  <binary-tree :info="info"></binary-tree>
</template>

<script>
  export default {
    data() {
      return {
        info: [[[2], 12, [8]], 15, [[4], 7]]
      }
    }
  }
</script>
```

最大堆要求父节点的值要比子节点的值要大，并且在插入和删除的过程中始终保持这样的关系。作为树的根节点，其值比所有的子节点的值要大。而最小堆与之相反。下面详细介绍操作堆的基本步骤。

### 插入过程

在插入的过程中，首先将要插入的节点放置在最下方的叶子位置，再调整该位置直至堆满足条件。

```VUE
<template>
  <binary-tree :info="info"></binary-tree>
</template>

<script>
  const s = {
    value: 13,
    types: ['green']
  };
  
  export default {
    data() {
      return {
        info: [[[2], 12, [8]], 15, [[4], 7, [s]]]
      }
    }
  }
</script>
```

如上图所示。当 13 处于叶子位置时，其父节点 $7 < 13$，故而不符合条件，需要调整 13 和 7 的位置。交换这两个节点：

```VUE
<template>
  <binary-tree :info="info"></binary-tree>
</template>

<script>
  const s = {
    value: 13,
    types: ['green']
  };
  const w = {
    value: 7,
    types: ['blue']
  };
  
  export default {
    data() {
      return {
        info: [[[2], 12, [8]], 15, [[4], s, [w]]]
      }
    }
  }
</script>
```

因为 7 为父节点时，堆是符合条件的，因此 7 所有的子节点的值 $v$ 都满足 $v \le 7$，换为 13 后仍然符合条件。交换后，13 小于其父节点 15 的值，进而无需交换，此时堆保持合法。

最复杂的情况下（插入一个最大值），插入操作需要进行 $h$ 次交换操作，$h$ 为树的高度。二叉堆中树的高度为 $\log n$，$n$ 为堆中元素数目。进而插入操作的复杂度为 $O(\log n)$。

### 删除过程

```VUE
<template>
  <binary-tree :info="info"></binary-tree>
</template>

<script>
  const d = {
    value: 15,
    types: ['red']
  };
  export default {
    data() {
      return {
        info: [[[2], 12, [8]], d, [[4], 13, [7]]]
      }
    }
  }
</script>
```

如上图所示，现在将最大值 15 删除。删除 15 后，我们依旧需要保持堆的属性。所以选择一个叶子节点，将其移动到树的根位置：

```VUE
<template>
  <binary-tree :info="info"></binary-tree>
</template>

<script>
  const s = {
    value: 7,
    types: ['green']
  };
  export default {
    data() {
      return {
        info: [[[2], 12, [8]], s, [[4], 13]]
      }
    }
  }
</script>
```

为了继续保持该堆，需要对 7 的位置进行调整。$7 < 12$ 且 $7 < 13$，这里会选择一个能让大小关系继续保持的节点与 7 进行交换，也就是 13。交换完成后：

```VUE
<template>
  <binary-tree :info="info"></binary-tree>
</template>

<script>
  const s = {
    value: 7,
    types: ['green']
  };
  const w = {
    value: 13,
    types: ['blue']
  }
  
  export default {
    data() {
      return {
        info: [[[2], 12, [8]], w, [[4], s]]
      }
    }
  }
</script>
```

此时 7 所处的位置，子节点只有 4，且 $4 < 7$，进而操作完毕。

同样的，删除操作的复杂度也是 $O(\log n)$。

（未完待续。。。）
# 使用 C++ 实现简单内存池

14 年 9 月左右参加腾讯校招时的笔试题。当时在纸上写了代码，也不确定是否可用。现在是 17 年 3 月，为了实习面试的招聘顺利点，决定重新实现一遍，基本要求如下：

1. 面向对象；
2. 初始化内存池、申请内存、释放内存三个操作；
3. 尽量小的复杂度，优先优化时申请内存时的复杂度；
4. 加入单元测试和性能测试。

### 1. 面向对象框架

```c++
class MemoryPool {
    MemoryPool(int pool_size);
    void* alloc(int size);
    bool release(void *ptr);
}
```

### 2. 基本操作实现

首先，内存池直接返回真实的内存指针，进而无法在代码执行过程中对内存段的位置进行调整，所以空余空间可能很大，但被切开、四散的情况是存在的。这里不考虑这样的情况，需要实现的操作如下：

1. 初始化内存池：直接使用 new 申请一大段空间作为内存池；
2. 申请内存：若长度足够，则从内存池中选择指定长度的连续未使用段返回，并标记该段已使用；否则返回 NULL；
3. 释放内存：查询 ptr 是否是标记的，若是则回收，将该段标记为未使用，并返回 true；若否则返回 false。

首先简单点，看释放内存的操作。使用一个 used[position] 的字典，记录所有指针对应的内存段的大小；释放时直接查询 used 字典，若存在 ptr 指针，则处理，否则直接返回 false。

这里说的处理，即将该段内存由“使用中”标记为“未使用”，并从 used 字典中删除，而并不需要对数组清零（节约时间）。另外，如果该段内存左右有其他空余的内存段，需要进行合并，为下一次申请大内存做准备。

而申请内存时，最优的操作是找到恰好大于等于当前需要长度的未使用内存段并返回，同时标记该段为“使用中”，内存段长度大于需求长度则进行切分，同样将剩下的部分作为“可使用”的内存段。

如下图所示，依次申请了 4 个字节、2 个字节、2 个字节和 4 个字节。

```VUE
<template lang="pug">
  .component
    .square_row
      .container(v-for="i in l")
        .square(v-bind:class="colors[i]")
</template>

<script>
  export default {
    data() {
      return {
        colors: ['transparent', 'red', 'gray', 'blue', 'green', 'yellow'],
        n: 16,
        l: [1, 1, 1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 0, 0, 0, 0]
      }
    }
  }
</script>

<style lang="less" scoped>
  .component {
    margin: 10px;
    .transparent {}
    .red { background-color: red; }
    .gray { background-color: gray; }
    .blue { background-color: blue; }
    .green { background-color: green; }
    .yellow { background-color: yellow; }

    .square_row {
      display: flex;

      .container {
        flex: 1;

        .square {
          position: relative;
          width: 100%;
          padding-bottom: 100%;
          border: lightgray 1px solid;
        }
      }
    }

    .operation {
      margin: 10px auto;
      text-align: center;
    }
  }
</style>
```

现释放第二次和第三次申请的内存，则内存占用变为：

```VUE
<template lang="pug">
  .component
    .square_row
      .container(v-for="i in l")
        .square(v-bind:class="colors[i]")
</template>

<script>
  export default {
    data() {
      return {
        colors: ['transparent', 'red', 'gray', 'blue', 'green', 'yellow'],
        n: 16,
        l: [1, 1, 1, 1, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0]
      }
    }
  }
</script>

<style lang="less" scoped>
  .component {
    margin: 10px;
    .transparent {}
    .red { background-color: red; }
    .gray { background-color: gray; }
    .blue { background-color: blue; }
    .green { background-color: green; }
    .yellow { background-color: yellow; }

    .square_row {
      display: flex;

      .container {
        flex: 1;

        .square {
          position: relative;
          width: 100%;
          padding-bottom: 100%;
          border: lightgray 1px solid;
        }
      }
    }

    .operation {
      margin: 10px auto;
      text-align: center;
    }
  }
</style>
```

（未完待续。。。）
# 使用 C++ 实现简单内存池

14 年 9 月左右参加腾讯校招时的笔试题。当时在纸上写了代码，也不确定是否可用。现在是 17 年 3 月，为了实习面试的招聘顺利点，决定重新实现一遍，基本要求如下：

1. 面向对象；
2. 初始化内存池、申请内存、释放内存三个操作；
3. 尽量小的复杂度，优先优化时申请内存时的复杂度；
4. 加入单元测试和性能测试。

### 1. 面向对象框架

```c++
class MemoryPool {
    MemoryPool(int pool_size);
    void* alloc(int size);
    bool release(void *ptr);
}
```

### 2. 基本操作实现

首先，内存池直接返回真实的内存指针，进而无法在代码执行过程中对内存段的位置进行调整，所以空余空间可能很大，但被切开、四散的情况是存在的。这里不考虑这样的情况，需要实现的操作如下：

1. 初始化内存池：直接使用 new 申请一大段空间作为内存池；
2. 申请内存：若长度足够，则从内存池中选择指定长度的连续未使用段返回，并标记该段已使用；否则返回 NULL；
3. 释放内存：查询 ptr 是否是标记的，若是则回收，将该段标记为未使用，并返回 true；若否则返回 false。

首先简单点，看释放内存的操作。使用一个 used[position] 的字典，记录所有指针对应的内存段的大小；释放时直接查询 used 字典，若存在 ptr 指针，则处理，否则直接返回 false。

这里说的处理，即将该段内存由“使用中”标记为“未使用”，并从 used 字典中删除，而并不需要对数组清零（节约时间）。另外，如果该段内存左右有其他空余的内存段，需要进行合并，为下一次申请大内存做准备。

而申请内存时，最优的操作是找到恰好大于等于当前需要长度的未使用内存段并返回，同时标记该段为“使用中”，内存段长度大于需求长度则进行切分，同样将剩下的部分作为“可使用”的内存段。

如下图所示，内存池一共有 16 个字节。依次申请了 4 个字节、2 个字节、2 个字节和 4 个字节的内存，内存池占用如下图所示：

```VUE
<template>
  <div>
    <memory-view :used="used" :length="length">
    </memory-view>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        used: [
          [0, 4, 1],
          [4, 2, 2],
          [6, 2, 3],
          [8, 4, 4]
        ],
        length: 16
      }
    }
  }
</script>
```

现释放第一次和第三次申请的内存，则内存池占用变为：

```VUE
<template>
  <div>
    <memory-view :used="used" :length="length">
    </memory-view>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        used: [
          [4, 2, 2],
          [8, 4, 4]
        ],
        length: 16
      }
    }
  }
</script>
```

而如果现在需要释放第二次申请的 2 个字节，则前 8 个字节均为空，也就是说要将 [4, 5] 与 [0, 3] 和 [6, 7] 这两个区间连接在一起，重新构建出一个大的未使用空间 [0, 7]。

这也就需要在释放操作中查询当前内存段左右两边未使用的段。故而这里需要构建一个 empty_start 字典，记录所有“未使用”的段，key 值为起始位置，value 为段长度。empty_start 可以解决释放操作中查询右边未使用段的需求，对于左侧的未使用段还是没办法直接查，故而还需要建立一个 key 值为重点位置，value 为段长度的“未使用”段的字典，标记为 empty_end。至此释放操作的问题解决。

对于申请操作，每次需要查询内存池中大于等于指定长度的连续未使用段，最优的查询结果是段越短越好（这样剩余空间可以满足更多的大内存申请需求）。所以需要另一个字典存储指定长度的未使用段，这样的段可能有多个，进而该字典的 key 设为长度，value 为一个 set 集合，存储所有长度为 key 的未使用段的起点，该字典标记为 empty_length。每次申请时先查询 第一个大于等于指定长度的 key，若不存在则直接返回 NULL；若存在则在 empty_length[key] 集合中任意选择一个起点，将该段从 empty_length[key] 集合中删除，以及 empty_start、empty_end 中删除，并加入 used 数组。若该段较需求长度更长，则将剩下的段加入 empty_start、empty_end 和 empty_length。至此申请操作的问题解决。

### 3. 实现和复杂度分析

申请操作中需要对 empty_length 字典中做查询，查询第一个大于等于要求长度的 key。该操作的复杂度最低为 $O(\log n)$，$n$ 为字典大小，可以使用 C++ 提供的 map 实现。

对于 empty_start、empty_end 和 used 的操作，以及 empty_length[key] 集合，并不需要知道 key 值有序，故而可以直接使用 C++ 11 提供的 unordered_map 和 unordered_set，加快执行速度。这两种数据结构均使用 Hash，存储和读取的复杂度可认为是 $O(1)$。

这样整体上申请内存的复杂度为 $O(\log n)$，释放内存的复杂度为 $O(1)$，$n$ 为字典大小，或者说是内存池中段的数目。

（未完待续。。。）
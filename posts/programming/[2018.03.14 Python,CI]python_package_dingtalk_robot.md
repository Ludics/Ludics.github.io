# Build a Python Package Step by Step

>  今天是 π 节，祝大家 π 节快乐 :D

通常大家使用 Python 提供的包的时候，无外乎使用 `pip` 完成安装，然后在源代码头部使用 `import` 引入需要的包，再来就可以愉快地使用了。对于初学者来说，可能会困惑，要如何构建这样一个简单易用的包呢？

由此本文应运而生，这里将带大家一步一步实现一个这样的 Python 包。包的功能是封装钉钉群聊中自定义机器人的 HTTP API，方便 Python 用户直接调用该包实现机器人的消息发送。[点击此处可以查看钉钉自定义机器人的文档](https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.0I6tty&treeId=257&articleId=105735&docType=1)。

整个过程包含以下几步：

1. 编写功能代码；
2. 编写单元测试；
3. 构建 Python 包；
4. 上传 Python 包到 [PyPI](https://pypi.python.org/pypi/)；
5. 配置 CI；
6. 配置 CD。

### 1. 编写功能代码

根据钉钉自定义机器人的文档，可以通过向如下的链接发送 POST 请求来实现发送消息的功能。

```
https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxx
```

链接中的 `xxxxxxxx` 为 `Token`，该值可以在机器人的配置中找到。

发送文本消息需要 POST 的内容如下，发送其他消息类型可以参看文档。

```json
{
  "msgtype": "text", 
  "text": {
    "content": "我就是我, 是不一样的烟火"
  }
}
```

发送 POST 请求的操作可以使用 Python 中的 `requests` 库来实现，下面就可以写代码了。

这里将该库命名为 `dingtalk_robot`。找一个空文件夹，新建一个 `dingtalk_robot.py` 文件。这里确定仅需要一个源代码文件，如果有多个源代码文件，可以建立一个名为 `dingtalk_robot` 的文件夹，并在该文件夹中使用 `__init__.py` 引入各个源代码文件。

`dingtalk_robot.py` 中，实现钉钉自定义机器人的 HTTP API：

```python
import requests


class DingtalkRobot:
    BaseUrl = 'https://oapi.dingtalk.com/robot/send?access_token='

    def __init__(self, token: str):
        self.token = token
        self.access_url = self.BaseUrl + token

    def send_text(self, content: str):
        message = {
            'msgtype': 'text',
            'text': {
                'content': content
            }
        }

        response = requests.post(url=self.access_url, json=message)
        status = response.json()
        if status['errcode'] != 0:
            raise DingtalkRobot.Error('Error Code: {}, {}'.format(
                status['errcode'],
                status['errmsg']
            ))

    class Error(ValueError):
        pass
```

注意到代码中自定义了一个 `Error` 类。钉钉自定义机器人的 HTTP 接口有状态返回码，如果返回值异常则抛出这样一个 `Error`。

另外需要注意 `requests` 可能也会抛出网络相关的异常类，使用包的过程中同样需要做好异常处理。

至此本步骤完成。

### 2. 编写单元测试

单元测试，是针对程序模块来进行正确性检验的测试工作。Python 自带了单元测试框架 `unittest`，[点击此处可以查看 `unittest` 的官方文档](https://docs.python.org/3/library/unittest.html)。

单元测试简单来说，就是在正常使用一个类或者一个函数的功能，并在测试中对比预期结果与运行结果是否一致。如果不一致则说明代码出了问题。

在同上的文件夹中，新建单元测试文件 `test_dingtalk_robot.py`。按照 `unittest` 的文档，编写如下的测试代码：

```python
import unittest
from dingtalk_robot import DingtalkRobot


class MyTestCase(unittest.TestCase):
    valid_token = 'e2bfbac46ed921563dcd852ae65b3adc7797db997ea6c2cc75843b74e4365842'
    invalid_token = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'

    def test_send_text(self):
        dingtalk_robot = DingtalkRobot(token=self.valid_token)
        success = dingtalk_robot.send_text('Send text to Dingding')
        self.assertTrue(success)

    def test_send_text_to_invalid_token(self):
        dingtalk_robot = DingtalkRobot(token=self.invalid_token)
        error_here = False

        try:
            dingtalk_robot.send_text('Send text to Dingding')
        except dingtalk_robot.Error as e:
            error_here = True

        self.assertTrue(error_here)


if __name__ == '__main__':
    unittest.main()
```

这里分别测试了向正常 `token` 和异常 `token` 发送消息。正常 `token` 发送成功，而异常 `token` 发送失败抛出异常。

测试代码完成后，可以运行单元测试命令进行测试。这里推荐使用 `pytest`。执行 `pytest`，得到如下的输出：

```
==================== test session starts =====================
platform darwin -- Python 3.6.4, pytest-2.9.2, py-1.4.33, pluggy-0.3.1
benchmark: 3.1.1 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /Users/sfzhou/Code/07_Python/04_DingtalkRobot, inifile:
plugins: tornado-0.4.5, timeout-1.2.1, pep8-1.0.6, cov-2.5.1, benchmark-3.1.1
collected 2 items

test_dingtalk_robot.py ..

================== 2 passed in 0.52 seconds ==================
```

可以看到两个测试均通过，本步骤完成。

[未完待续]


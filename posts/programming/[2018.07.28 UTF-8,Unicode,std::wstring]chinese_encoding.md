# C++ 中的中文编码

中文编码是一个复杂而繁琐的问题，在 C++ 程序设计中尤是如此。近期笔者在工作中对这一点颇有体会，故而在总结一些经验。

### 一、ASCII 码

[`ASCII 码`](https://ascii.cl/)，全程 American Standard Code for Information Interchange，一共规定了 128 个字符的编码，包括 10 个阿拉伯数字（从 `0x30` 开始）、26 个大写字母（从 `65` 开始）、26 个大写字母（从 `97` 开始），33 个英文标点符号，及 32 个控制字符，还有最后一个 `0x7F`。

128 个字符，至少需要 7 个比特（bit）来表示，而一个字节（byte）有 8 个比特，故将字节的最高位的比特规定为 0，使用剩下的 7 个比特，刚好可以完整的表示 ASCII 码规定的字符。

阿拉伯数字的编码从 `0x30` 到 `0x39`，按顺序分别表示 0 到 9 这 10 个字符。这样带来了一个优势：可以直接做字符的减法，得到字符对应的数字大小。大写字母和小写字母亦是如此。举个例子：

```c++
char ch_9 = '9';
int value = ch_9 - '0';
assert(value == 9);
```

大写字母从 `0x41` 开始，小写字母从 `0x61` 开始。注意观察，二者相差了一个 `0x20`，即 32。任意一个小写字母对比对应的大写字母，仅第 6 个比特有 1 与 0 的不同。进而可以通过这一点进行大小写字母的判断及其转换。

ASCII 中的控制字符较为少用，有印象的仅仅是 `Bell` 字符（0x07）。大一学习编程的时候发现可以通过 `printf("\a");` 使用电脑发出蜂鸣声，如今在 Mac 上尝试依然有效。

### 二、中文编码

ASCII 码仅规定了 128 个字符，只能满足英文的基本需求。一个字节最多能表示 256 个字符，而中文的常用汉字就有数千了，故而需要使用多个字节来表示汉字。两个字节可以表示的字符上限为 65536，绝大部分情况下能够满足汉字使用的需求了。经典的汉字编码包括 GBK、GB2312、GB18030、CP939 等。

在汉字编码中，之前 ASCII 码没有使用的最高位派上了用场。如果一个字节最高位是 0，说明这个字节便是 ASCII 码，查表解析即可；如果最高位非 0，那么说明这是一个多字节编码，需要联合下一个字节一起进行解析。

不同的编码，也就意味着要查询不同的表，也就会得到不同的解码结果。年纪大点的人应该会懂，把小说下载到 MP3 里结果都是乱码的痛苦。再加上这个世界不止有中文，全球各个地区的文字、符号数量远超出两个字节可以表示的范围，这时“统一度量衡”就显得尤为重要了。

### 三、Unicode

Unicode 便是便是文字和符号的统一度量衡。Unicode，Unique Code，Universe Code，全世界每一个字符对应一个唯一的编码。Unicode 收录了大量的汉字，汉字的编码从 `0x4E00` 开始，到 `0x9FFF` 结束。

然而 Unicode 仅仅定义了符号与二进制编码的关系，但没有定义如何存储和解析这些二进制编码。如果直接将二进制编码写入文件，那么读取时会产生歧义。例如 `4E 00 41`，你无法知道这记录的是 1 一个字符，还是 2 个字符（可以解码为“一A”），或者是 3 个字符（可以解码为“N[空]A”）。如果统一每个字符的记录长度，那么便需要至少 3 个字节来表示一个符号，那么对于全英的文件则太浪费了。

### 四、UTF-8

Unicode 解决了编码统一的问题，但没有解决编码存储和解析的问题。UTF-8 则解决了 Unicode 没有解决的问题。

UTF-8 是一种变长编码，会使用 1 到 4 个字节便是一个字符，类似于哈夫曼树，具体与 Unicode 的映射关系如下（复制自参考文献1）：

| Unicode 范围（十六进制） |      UTF-8 编码方式（二进制）       |
| :----------------------: | :---------------------------------: |
|  0000 0000 ~ 0000 007F   |              0xxxxxxx               |
|  0000 0080 ~ 0000 07FF   |          110xxxxx 10xxxxxx          |
|  0000 0800 ~ 0000 FFFF   |     1110xxxx 10xxxxxx 10xxxxxx      |
|  0001 0000 ~ 0010 FFFF   | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

UTF-8 对于原有的 ASCII 码完全兼容，而最高位的 1 的数量表示当前字符占用的字节数。可以通过上表将 Unicode 转换为 UTF-8 编码，即将 x 按照高低位顺序替换为 Unicode 的二进制位，缺了则使用 0 补齐。以汉字“一”为例，其 Unicode 编码为 `0x4E00`，对应的二进制为 `100 1110 0000 0000 `，二进制共计 15 位。填充到 ` 1110xxxx 10xxxxxx 10xxxxxx` 中，最高位缺了一位，使用 0 补齐，最终可得 `11100100 10111000 10000000`，即 `E4 B8 80`。使用一行 Python3 代码验证一下：

```python
print(b'\xe4\xb8\x80'.decode())
# 打印结果：一
```

根据映射关系表可知，英文字符在 UTF-8 中使用一个字节存储，中文字符使用三个字节存储。并且可以轻松地写出 Unicode 与 UTF-8 间的转换程序。

[未完待续]

### 参考文献

1. [阮一峰. "字符编码笔记：ASCII，Unicode 和 UTF-8."](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)
# Paper Reading on Deep Compressed Sensing

## 1. Learning a Compressed Sensing Measurement Matrix via Gradient Unrolling

### 3.1 Abstract

> Linear encoding of sparse vectors is widely popular, but is commonly data-independent – missing any possible extra (but a priori unknown) structure beyond sparsity. In this paper, we present a new method to learn linear encoders that adapt to data, while still performing well with the widely used $\mathcal{l}_1$ decoder. The convex $\mathcal{l}_1$ decoder prevents gradient propagation as needed in standard gradient-based training. Our method is based on the insight that unrolling the convex decoder into T projected subgradient steps can address this issue. Our method can be seen as a data-driven way to learn a compressed sensing measurement matrix. We compare the empirical performance of 10 algorithms over 6 sparse datasets (3 synthetic and 3 real). Our experiments show that there is indeed additional structure beyond sparsity in the real datasets; our method is able to discover it and exploit it to create excellent reconstructions with fewer measurements (by a factor of 1.1-3x) compared to the previous state-of-the-art methods. We illustrate an application of our method in learning label embeddings for extreme multi-label classification, and empirically show that our method is able to match or outperform the precision scores of SLEEC, which is one of the state-of-the-art embedding-based approaches.

### 3.2 Introduction

Design a measurement matrix $A \in \mathbb{R}^{m \times d}$, such that for an ill-posed problem $y = Ax$ where $x \in \mathbb{R}^d$ and $y \in \mathbb{R}^m$, and $m < d$. The problem of designing measurement matrices and reconstruction algorithms that recover sparse vectors from linear observations is called Compressed Sensing (CS), Sparse Approximation or Sparse Recovery Theory.

The problem can be solved as follows:

$$
\argmin _{x' \in \mathbb{R}^d} \parallel x' \parallel _0  \quad \mathrm{s.t.} \quad Ax'=y
$$

But it's a NP-Hard problem. With some properties such as Restricted Isometry Property (RIP) or the nullspace condition (NSP), $\mathcal{l}_0$ norm can be relaxed to $\mathcal{l}_1$ norm:

$$
D(A, y) = \argmin _{x' \in \mathbb{R}^d} \parallel x' \parallel _1  \quad \mathrm{s.t.} \quad Ax'=y
$$

The authors interested in vectors that are not only sparse but have additional structure in their support. They propose a data-driven algorithm that learns a good linear measurement matrix $A$ from data samples. Their linear measurements are subsequently decoded with the $\mathcal{l}_1$-minimization to estimate the unknown vector x.

Our method is an autoencoder for sparse data, with a linear encoder (the measurement matrix) and a complex non-linear decoder that approximately solves an optimization problem.

PCA is a data-driven dimensionality reduction method and an autoencoder with encoder and decoder all linear, and is provides the lowest MSE. Linear encoder has advantages, 1) easy to compute matrix-vector multiplication; 2) easy to interpret as every column of the encoding matrix can be viewed as feature embedding. Arora et al. found that pre-trained word embeddings such as GloVe and word2vec formed a good measurement matrices for text data, which need fewer mearusements than random matrces when used with $\mathcal{l}_1$-minimization.

Given $n$ sparse samples $x_1, x_2, \dots, x_n \in \mathbb{R}^d$, our problem is to find the best $A$:

$$
\min \limits_{A \in \mathbb{R}^{m \times d}} f(A), \quad \mathrm{where} \quad f(A) := \sum_{i=1}^{n} \parallel x_i - D(A, Ax_i) \parallel_2^2
$$

where $D(·,·)$ is the $\mathcal{l}_1$ decoder.

$f(A)$关于$A$的梯度很难求解，因为$D(\cdot, \cdot)$是由一个优化问题确定的。作者的创新点就在这里，将$\mathcal{l}_1$最小化转变成了T步的投影子梯度的更新，这样梯度就可以计算了。即

$$
\begin{aligned}
\hat{f}(A) :&= \sum_{i=1}^n \lVert x_i - \hat{x}_i\rVert^2_2, \mathrm{where} \\
\hat{x}_i &=T\mathrm{step \, subgradient \, of\, } D(A,Ax_i), \mathrm{for}\, i = 1,2,\cdots,n.
\end{aligned}
$$

这个步骤就被称为**梯度展开**（gradient unrolling）。推导过程：

- 原始最小化问题：

$$
\min_{x'\in \mathbb{R}^d} \lVert x' \rVert_1 \quad \mathrm{s.t.} \quad Ax'=y
$$

- 映射子梯度方法的更新为

$$
x^{(t+1)} = \Pi(x^{(t)} - \alpha_t g^{(t)}), \quad \mathrm{where} \quad g^{(t)} = \mathrm{sign}(x^{(t)})
$$

其中，$\Pi$表示到凸集$\{x':Ax'=y\}$上的投影，$g^{(t)}$是符号函数，也就是$\lVert\cdot\rVert_1$在$x^{(t)}$处的子梯度，$\alpha_t$是第t个迭代的步长。因为$A$是行满秩矩阵，$\Pi$有如下闭式解：

$$
\begin{aligned}
\Pi(z) & = \argmin_h\lVert h-z\rVert_2^2 \quad \mathrm{s.t.} Ah=y \\
&=z + \argmin_{h'}\lVert h'\rVert_2^2 \quad \mathrm{s.t.} Ah'=y-Az \\
&= z + A^{+}(y-Az)
\end{aligned}
$$

这里的$A^+ = A^\mathrm{T}(AA^\mathrm{T})^{-1}$是$A$的伪逆。带入上式，又$Ax^{(t)}=y$，有

$$
x^{(t+1)} = x^{(t)} - \alpha_t (I-A^+A)\mathrm{sign}(x^{(t)})
$$

使用$x^{(1)}=A^+y$作为起始点。

根据一个引理，我们有理由使用$A^T$来替换$A^+$，因为$A^+$的计算很麻烦，而且难以反向传播。具体的引理内容参见论文。最终的迭代形式成为：

$$
x^{(t+1)} = x^{(t)} - \alpha_t (I-A^\mathrm{T}A)\mathrm{sign}(x^{(t)})
$$

引理要求$A$的奇异值都为1，训练时并没有添加这个约束，但是最终得到的测量矩阵和约束集很接近。网络结构如下：

![Net Arch](../images/l1ae1.png)

经过$T$个 `block`，输出为$x^{(T+1)}$，再进入激活层，最终输出为$\hat{x}=\mathrm{ReLU}(x^{(T+1)})$。对于给定的n个无标签训练数据，我们训练的目的是减小$x$与$\hat{x}$之间的均方$\mathcal{l}_2$距离：

$$
\min_{A\in \mathbb{R}^{m\times d}, \beta\in \mathbb{R}}\frac{1}{n}\sum_{i=1}^n \lVert x-\hat{x}\rVert_2^2
$$

对于这样学到的线性编码器$A$，我们可以使用$\mathcal{l}_1$解码器进行解码，作者使用`Gurobi`进行解码，因此整套算法可以写成$L1AE+L1min pos$。这样学到的编码器与$\mathcal{l}_1$解码器和基于模型的解码器都可以有很好的表现。

作者还发现$L1AE$可以用于XML（极多标签学习）。

## 2. Deep Compressed Sensing

